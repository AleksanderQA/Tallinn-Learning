<details>
  <summary>Agile/Scrum methodologies</summary>
 

# [^1]: <b>Agile Methodology<b>
# Ретроспектива
# Ключевые концепции Agile  

![arrowdown](https://github.com/UserQA07/Tallinn-Learning/assets/144763744/74e68fd7-0356-4043-91d9-2d3424eb8f57)

## Пользовательские истории (User Stories):
после консультации с заказчиком или владельцем продукта команда делит работу, которую необходимо выполнить, на функциональные этапы, называемые «пользовательскими историями». Ожидается, что каждая пользовательская история внесет свой вклад в ценность всего продукта;

## Ежедневные собрания (Daily Meeting):
каждый день в одно и то же время группа собирается, чтобы ознакомить всех с информацией, которая имеет жизненно важное значение для координации: каждый член команды кратко описывает все «завершенные» вклады и любые препятствия, стоящие на их пути;

## Персонажи (Personas):
когда этого требует проект - например, когда пользовательский опыт является основным фактором результатов проекта - команда создает подробные синтетические биографии фиктивных пользователей будущего продукта: они называются personas;

## Команда (Team): «Команда» в Agile понимании -
это небольшая группа людей, назначенных на один и тот же проект или effort, почти все из них на постоянной основе. Незначительное меньшинство членов команды может работать неполный рабочий день или иметь конкурирующие обязанности;

## Инкрементальная разработка (Incremental Development): 
почти все Agile-команды отдают предпочтение стратегии инкрементального развития; в контексте Agile это означает, что можно использовать каждую последующую версию продукта, и каждая основывается на предыдущей версии, добавляя видимые для пользователя функциональные возможности;

## Итеративная разработка (Iterative Development):
Agile-проекты являются итеративными, поскольку они намеренно позволяют «повторять» действия по разработке программного обеспечения и потенциально «пересматривать» одни и те же рабочие продукты;

## Ретроспектива (Milestone Retrospective):
после того, как проект был запущен в течение некоторого времени или в конце проекта, все постоянные члены команды (не только разработчики) вкладывают от одного до трех дней в подробный анализ значимых событий проекта.

# Scrum Methodology

## Scrum - 
наиболее популярный Agile-фреймворк, для многих людей эти термины являются синонимами. Scrum - это фреймворк процесса, используемый для управления разработкой продукта и другой работой, связанной с знаниями. Скрам является эмпирическим в том смысле, что дает командам возможность установить гипотезу о том, как они думают, что что-то работает, опробовать это, проанализировать полученный опыт и внести соответствующие коррективы. То есть при правильном использовании фреймворка. Скрам структурирован таким образом, чтобы команды могли использовать практики из других фреймворков, которые имеют смысл для контекста команды.
Scrum лучше всего подходит в случае, когда кросс-функциональная команда работает в среде разработки продукта, где есть нетривиальный объем работы, которую можно разделить на более чем одну 2-4-недельную итерацию.

## Ценности:
## Преданность (Commitment):
Члены команды лично привержены достижению целей команды;

## Смелость (Courage):
Члены команды поступают правильно и работают над сложными проблемами;
## Сфокусированность (Focus):
Сконцентрируйтесь на работе, намеченной для спринта, и целях команды;

## Открытость (Openness):
Члены команды и заинтересованные стороны открыто рассказывают обо всей работе и проблемах, с которыми сталкивается команда;

## Уважение (Respect):
Члены команды уважают друг друга за способности и независимость.

## Принципы:

## Прозрачность (Transparency):
Команда должна работать в среде, где каждый знает, с какими проблемами сталкиваются другие члены команды. Команды выявляют проблемы внутри организации, часто возникающие в течение длительного времени, которые мешают успеху команды;
## Инспекция (Inspection): 
Частые контрольные точки встроены в структуру, чтобы дать команде возможность поразмышлять о том, как работает процесс. Эти контрольные точки включают в себя Daily Scrum meeting и the Sprint Review Meeting;
## Адаптация (Adaptation): 
Команда постоянно изучает, как идут дела, и проверяет те пункты, которые кажутся бессмысленными.

# События:
## Спринт (Sprint): 
это временной интервал в 2-4 недели, в течение которого команда создает потенциально готовый к поставке инкремент продукта;
# Планирование спринта (Sprint Planning):
Команда начинает спринт с обсуждения, чтобы определить, над какими элементами из бэклога продукта (product backlog) они будут работать во время спринта. Конечным результатом планирования спринта является бэклог спринта (Sprint Backlog). Планирование спринта обычно состоит из двух частей. В первой части владелец продукта и остальная часть команды согласовывают, какие элементы бэклога продукта будут включены в спринт. Во второй части планирования спринта команда определяет, как они будут успешно доставлять идентифицированные элементы Product Backlog как часть потенциально возможного инкремента продукта. Команда может определить конкретные задачи, необходимые для этого, если это одна из их практик. Элементы Product Backlog, определенные для доставки, и задачи, если применимо, составляют бэклог спринта. После того, как команда и владелец продукта установят объем спринта, как описано в элементах Product Backlog, никакие дополнительные элементы не могут быть добавлены в журнал Sprint Backlog. Это защищает команду от изменений в рамках этого спринта;
# Ежедневная встреча (Daily Scrum/Meeting):
это короткое (обычно не более 15 минут) обсуждение, во время которого команда координирует свои действия на следующий день. Дейли не предназначен для обсуждения статуса или обсуждения проблем;
# Обзор спринта (Sprint Review):
в конце спринта вся команда (включая владельца продукта) рассматривает результаты спринта с заинтересованными сторонами продукта. Цель этого обсуждения - обсудить, продемонстрировать и потенциально дать заинтересованным сторонам возможность использовать инкремент для получения обратной связи. Обзор спринта не предназначен для предоставления отчета о состоянии (status report). Отзывы об обзоре спринта помещаются в Product Backlog для дальнейшего рассмотрения;
# Ретроспектива спринта (Sprint Retrospective):
в конце спринта после обзора спринта (sprint review) команда (включая владельца продукта) должна подумать о том, как дела шли во время предыдущего спринта, и определить корректировки, которые они могут внести в будущем. Результатом этой ретроспективы является как минимум одно действие, включенное в бэклог следующего спринта;
Упорядочение бэклога (Grooming);

# Артефакты:
## Бэклог продукта (Product Backlog):
это упорядоченный список всех возможных изменений, которые могут быть внесены в продукт. Пункты в бэклоге продукта являются вариантами, а не обязательствами, и то, что они существуют в бэклоге продукта, не гарантирует, что они будут доставлены. Владелец продукта постоянно ведет бэклог продукта, включая его содержание, доступность и порядок;
## Бэклог спринта (Sprint Backlog):
это набор элементов из бэклога продукта, выбранных для доставки в спринте. После того, как команда определяет задачи, эти задачи необходимо выполнить для достижения цели спринта (Sprint Goal);
## Инкремент (Increment): 
это набор элементов из бэклога продукта, которые соответствуют Definition of Done к концу спринта. Владелец продукта может решить выпустить дополнение или развить его в будущих Спринтах;
## Критерии Готовности (Definition of Done):
это общее соглашение команды о критериях, которым должен соответствовать элемент бэклога продукта, прежде чем он будет считаться выполненным$
## Пользовательские истории (User Story);
## Цель спринта (Sprint Goal);
## Диаграмма сгорания задач (Burndown chart).
</details>

<details>
  <summary>Git commands</summary>
  


![image](https://github.com/UserQA07/-Git/assets/144763744/dd042beb-d672-4fb7-a3cc-7466e99ecd6b)


# Шпаргалка по Git, в которой представлены основные команды 

Git сегодня - это очень популярная система контроля версий. Поэтому шпаргалка по Git, состоящая из основных команд - это то, что может пригодиться.


# Шпаргалка по основным командам
# git add
Команда git add добавляет содержимое рабочей директории в индекс (staging area) для последующего коммита. По умолчанию git commit использует лишь этот индекс, так что вы можете использовать git add для сборки слепка вашего следующего коммита.

# git status
Команда git status показывает состояния файлов в рабочей директории и индексе: какие файлы изменены, но не добавлены в индекс; какие ожидают коммита в индексе. Вдобавок к этому выводятся подсказки о том, как изменить состояние файлов.

# git diff
Команда git diff используется для вычисления разницы между любыми двумя Git деревьями. Это может быть разница между вашей рабочей директорией и индексом (собственно git diff), разница между индексом и последним коммитом (git diff --staged), или между любыми двумя коммитами (git diff master branchB).

# git difftool
Команда git difftool просто запускает внешнюю утилиту сравнения для показа различий в двух деревьях, на случай если вы хотите использовать что-либо отличное от встроенного просмотрщика git diff.

# git commit
Команда git commit берёт все данные, добавленные в индекс с помощью git add, и сохраняет их слепок во внутренней базе данных, а затем сдвигает указатель текущей ветки на этот слепок.

# git reset
Команда git reset, как можно догадаться из названия, используется в основном для отмены изменений. Она изменяет указатель HEAD и, опционально, состояние индекса. Также эта команда может изменить файлы в рабочей директории при использовании параметра --hard, что может привести к потере наработок при неправильном использовании, так что убедитесь в серьёзности своих намерений прежде чем использовать его.

# git rm
Команда git rm используется в Git для удаления файлов из индекса и рабочей директории. Она похожа на git add с тем лишь исключением, что она удаляет, а не добавляет файлы для следующего коммита.

# git mv
Команда git mv — это всего лишь удобный способ переместить файл, а затем выполнить git addдля нового файла и git rm для старого.

# git clean
Команда git clean используется для удаления мусора из рабочей директории. Это могут быть результаты сборки проекта или файлы конфликтов слияний.

# Шпаргалка по ветвлению и слиянию

# git branch
Эта команда выведет список всех локальных веток, и активная ветка будет выделена звездочкой.

# git branch -r
Просмотреть удаленные ветки. Эта команда выведет список всех удаленных веток.

# git branch -a
Просмотреть и локальные, и удаленные ветки:
Если вы хотите увидеть как локальные, так и удаленные ветки, выполните команду :


git branch -a
Эта команда выведет список всех веток, включая локальные и удаленные. Локальные ветки будут отображены без каких-либо префиксов, а удаленные ветки будут представлены в формате "origin/branch_name" для удаленного сервера "origin".

# git log --graph --oneline --all
Графическое представление веток:
Эта команда отобразит древовидное представление всех веток, что поможет вам лучше понять, как они взаимосвязаны.


# git branch
Команда git branch — это своего рода “менеджер веток”. Она умеет перечислять ваши ветки, создавать новые, удалять и переименовывать их.

# git checkout
Команда git checkout используется для переключения веток и выгрузки их содержимого в рабочую директорию.

# git merge
Команда git merge используется для слияния одной или нескольких веток в текущую. Затем она устанавливает указатель текущей ветки на результирующий коммит.

# git mergetool
Команда git mergetool просто вызывает внешнюю программу слияний, в случае если у вас возникли проблемы слияния.

# git log
Команда git log используется для просмотра истории коммитов, начиная с самого свежего и уходя к истокам проекта. По умолчанию, она показывает лишь историю текущей ветки, но может быть настроена на вывод истории других, даже нескольких сразу, веток. Также её можно использовать для просмотра различий между ветками на уровне коммитов.

# git stash
Команда git stash используется для временного сохранения всех незакоммиченных изменений для очистки рабочей директории без необходимости коммитить незавершённую работу в новую ветку.

# git tag
Команда git tag используется для задания постоянной метки на какой-либо момент в истории проекта. Обычно она используется для релизов.

# Шпаргалка по совместной работе и обновлению проектов

Не так уж много команд в Git требуют сетевого подключения для своей работы, практически все команды оперируют с локальной копией проекта. Когда вы готовы поделиться своими наработками, всего несколько команд помогут вам работать с удалёнными репозиториями.

# git fetch
Команда git fetch связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

# git pull
Команда git pull работает как комбинация команд git fetch и git merge, т.е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

# git push
Команда git push используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.

# git remote
Команда git remote служит для управления списком удалённых репозиториев. Она позволяет сохранять длинные URL репозиториев в виде понятных коротких строк, например "origin", так что вам не придётся забивать голову всякой ерундой и набирать её каждый раз для связи с сервером. Вы можете использовать несколько удалённых репозиториев для работы и git remote поможет добавлять, изменять и удалять их.

# git archive
Команда git archive используется для упаковки в архив указанных коммитов или всего репозитория.

# git submodule
Команда git submodule используется для управления вложенными репозиториями. Например, это могут быть библиотеки или другие, используемые не только в этом проекте ресурсы. У команды submodule есть несколько под-команд — add, update, sync и др. — для управления такими репозиториями.

# Шпаргалка по осмотру и сравнению
git show
Команда git show отображает объект в простом и человекопонятном виде. Обычно она используется для просмотра информации о метке или коммите.

# git shortlog
Команда git shortlog служит для подведения итогов команды git log. Она принимает практически те же параметры, что и git log, но вместо простого листинга всех коммитов, они будут сгруппированы по автору.

# git describe
Команда git describe принимает на вход что угодно, что можно трактовать как коммит (ветку, тег) и выводит более-менее человекочитаемую строку, которая не изменится в будущем для данного коммита. Это может быть использовано как более удобная, но по-прежнему уникальная, замена SHA-1.

# Шпаргалка по отладке
В Git есть несколько команд, используемых для нахождения проблем в коде. Это команды для поиска места в истории, где проблема впервые проявилась и собственно виновника этой проблемы.

# git bisect
Команда git bisect — это чрезвычайно полезная утилита для поиска коммита в котором впервые проявился баг или проблема с помощью автоматического бинарного поиска.

# git blame
Команда git blame выводит перед каждой строкой файла SHA-1 коммита, последний раз менявшего эту строку и автора этого коммита. Это помогает в поисках человека, которому нужно задавать вопросы о проблемном куске кода.

# git grep
Команда git grep используется для поиска любой строки или регулярного выражения в любом из файлов вашего проекта, даже в более ранних его версиях.

</details>

<details>
  <summary>STLC/SDLC</summary>

![image](https://github.com/UserQA07/STLC-SDLC/assets/144763744/5ae89c31-52f9-40f2-8767-56ccb9b12267)

# STLC - Software Testing Lifecycle

это процесс тестирования, который включает в себя определенную последовательность шагов, чтобы гарантировать достижение целей в области качества. В процессе STLC каждое действие выполняется планомерно и систематически. Каждый этап имеет разные цели и результаты. У разных организаций разные этапы STLC, однако основа остается прежней.

# Каждая фаза STLC имеет критерии начала и окончания:

# Критерии входа (entry criteria):
Набор общих и специфичных условий для продолжения процесса с определенной задачей, например, фаза тестирования. Цель критериев входа - предотвращение начала задачи, которое может потребовать больше (бесполезных) усилий, чем на устранение не пройденных критериев входа. (Gilb and Graham)

# Критерии выхода (exit criteria):
Набор общих и специфичных условий, согласованных заранее с заинтересованными сторонами, для того, чтобы процесс мог официально считаться завершенным. Цель критериев выхода - предотвращение возможности, когда задание считается завершенным, однако еще существуют отдельные незавершенные части задания. Критерии выхода используются для отчетности, а также планирования того, когда остановить тестирование. (Gilb and Graham)

STLC имеет несколько взаимосвязанных фаз и в целом очень похож на SDLC. Эти фазы являются последовательными и называются:

# Анализ требований (Requirement Analysis):
один из важнейших этапов, потому что именно на нем можно почти бесплатно исправить недостатки проекта. Этап анализа требований также определяет потенциальную потребность в автоматизированном тестировании и позволяет производить экономические расчеты затрат на рабочую силу на основе оценки проекта. На этом же этапе обсуждаются и документируются критерии начала и окончания тестирования.
Entry Criteria: BRS (Business Requirement Specification)
Deliverables: список всех проверяемых требований, технико-экономическое обоснование автоматизации (если применимо);

# Планирование тестирования (Test Planning): 
на этом этапе формируется план тестирования, т.е. мы определяем действия и ресурсы, которые помогут достичь целей тестирования (участники и их роли, инструменты, окружение). Во время планирования мы также пытаемся определить метрики, метод сбора и отслеживания этих метрик. План составляют исходя из требований, тестовой стратегии и анализа рисков.
Entry Criteria: Requirements Documents;
Deliverables: Test Strategy, Test Plan, and Test Effort estimation document.

# Разработка тест-кейсов (Test Case Development):
подразумевает использование ручного и автоматизированного тестирования для достижения полного охвата функциональности программного обеспечения, при этом процесс основан на заранее установленных требованиях. Чаще всего тест-кейсы для автоматического тестирования пишутся отдельно, так как кейсы для ручного тестирования описаны в виде шпаргалок (cheat sheets).
Entry Criteria: Requirements Documents (Updated version);
Deliverables: Test cases, Test Scripts (if automation), Test data.

# Настройка тестовой среды (Test Environment Setup):
в плане тестирования четко указано, какую тестовую среду следует использовать. На этом этапе STLC настраиваются операционные системы и виртуальные машины, развертываются инструменты тестирования, такие как Selenium, Katalon Studio, а также тестовая среда и базы данных проекта. Мы также обращаемся с запросами к DevOps и администраторам, если требуется поддержка.
Entry Criteria: Test Plan, Smoke Test cases, Test Data;
Deliverables: Test Environment. Smoke Test Results.

# Выполнение тестов (Test Execution):
тесты выполняются на основе готовой тестовой документации и правильно настроенной тестовой среды. Все результаты тестирования регистрируются в Системе управления тестированием. Отрицательно пройденные тесты, в которых фактический результат отличается от ожидаемого, регистрируются как ошибки и передаются команде разработчиков на доработку с последующей перепроверкой после исправления.
Entry Criteria: Test Plan document, Test cases, Test data, Test Environment;
Deliverables: Test case execution report, Defect report, RTM.

# Завершение цикла испытаний (Test Cycle Closure):
окончательная генерация отчетов о тестировании для клиента. Они должны включать затраченное время, процент обнаруженных ошибок и положительных результатов тестирования, общее количество обнаруженных и исправленных ошибок. Что касается отдела тестирования, то это момент для анализа его работы, подведения итогов, анализа его продуктивности и возможности внести предложения по улучшению качества тестирования.
Entry Criteria: Test Case Execution report (убедитесь, что нет открытых high severity defects), Defect report;
Deliverables: Test Closure report, Test metrics.

# Разница STLC и SDLC
STLC и SDLC тесно связаны друг с другом, но они одновременно преследуют разные задачи с одной и той же целью, а именно:
сбор требований в желаемой форме и разработка заявленной функциональности (SDLC);
анализ требований, помощь клиенту и команде разработчиков и подтверждение качества реализованной функциональности (STLC).
Общая цель - удовлетворение клиента и получение максимально возможного балла на этапах верификации и валидации.


![image](https://github.com/UserQA07/STLC-SDLC/assets/144763744/5f3b6315-cc76-475e-b885-7ac4418b302b)

# SDLC -
это систематизированный процесс, этапы которого охватывают полный жизненный цикл программного обеспечения (Software Lifecycle) и который определяет различные этапы разработки программного обеспечения для создания высококачественного программного обеспечения, отвечающего ожиданиям клиентов и для улучшения эффективности разработки. Разработка системы должна быть завершена в заранее определенные сроки и стоимость. Каждая фаза жизненного цикла SDLC имеет свой собственный процесс и результаты, которые используются в следующей фазе.
Обычно он делится на шесть-восемь шагов, но менеджеры проектов могут объединять, декомпозировать или пропускать шаги, в зависимости от скоупа проекта.
В разных источниках фазы немного отличаются, но глобально суть везде одинакова.

# Фазы SDLC:
# Сбор и анализ требований (Requirement Gathering and Analysis):
На этом этапе от клиента собирается вся необходимая информация для разработки продукта в соответствии с их ожиданиями. Любые неясности должны быть разрешены сразу на этом этапе. Бизнес-аналитик и менеджер проекта назначили встречу с заказчиком, чтобы собрать всю информацию, например, что заказчик хочет построить, кто будет конечным пользователем, какова цель продукта. Перед созданием продукта очень важно понимание или знание продукта. Например, клиент хочет иметь приложение, которое включает денежные транзакции. В этом случае требование должно быть четким, например, какие транзакции будут выполняться, как они будут проводиться, в какой валюте они будут проводиться и т. д. После того, как сбор требований завершен, проводится анализ для проверки возможности разработки продукта. После четкого понимания требования создается документ SRS (Спецификация требований к программному обеспечению). Этот документ должен быть полностью понят разработчикам, а также должен быть рассмотрен заказчиком для использования в будущем;

# Дизайн (Design): 
На этом этапе требования, собранные в документе SRS, используются в качестве входных данных, и создается архитектура программного обеспечения, которая используется для реализации разработки системы. Создаются два вида дизайн-документов:
Высокоуровневый дизайн (HLD - High-Level Design):
Краткое описание и название каждого модуля;
Краткое описание функциональности каждого модуля;
Отношения интерфейсов и зависимости между модулями;
Таблицы базы данных, идентифицированные вместе с их ключевыми элементами;
Полные архитектурные схемы с подробными сведениями о технологиях.
Низкоуровневый дизайн (LLD - Low-Level Design):
Функциональная логика модулей;
Таблицы базы данных, которые включают тип и размер;
Полная детализация интерфейсов;
Решение всех типов проблем с зависимостями;
Список сообщений об ошибках;
Полные входные и выходные значения для каждого модуля.

# Разработка (Implementation or Coding):
Реализация / кодирование начинается, как только разработчик получает Design document. Дизайн программного обеспечения переведен в исходный код. На этом этапе реализуются все компоненты программного обеспечения;

# Тестирование (Testing):
Тестирование начинается после завершения кодирования и выпуска модулей для тестирования. На этом этапе разработанное программное обеспечение тщательно тестируется, и все обнаруженные дефекты передаются разработчикам для их исправления. Повторное тестирование, регрессионное тестирование проводится до тех пор, пока программное обеспечение не будет соответствовать ожиданиям клиента. Тестировщики обращаются к документу SRS, чтобы убедиться, что программное обеспечение соответствует стандарту заказчика;

# Развертывание (Deployment):
После тестирования продукта он развертывается в производственной среде или выполняется первое UAT (пользовательское приемочное тестирование), в зависимости от ожиданий клиента. В случае UAT создается копия производственной среды, и заказчик вместе с разработчиками выполняет тестирование. Если клиент остается доволен, то предоставляет согласие на релиз;

# Поддержка (Maintenance):
Основное внимание на этом этапе SDLC уделяется обеспечению того, чтобы потребности продолжали удовлетворяться и чтобы система продолжала работать в соответствии со спецификацией, упомянутой в первом этапе. После того, как система развернута и клиенты начинают использовать разработанную систему следует 3 вида активностей:
Исправление ошибок;
Обновление;
Улучшение.
</details>

<details>
<summary> Markdown cheatsheet</summary>

# ***Table of Contents***

# [^1]: **[Headers](#)**
# **[Emphasis](#)**
# **[Lists](#)**
# **[Links](url)**
# **[Images](#)**
# **[Code and Syntax Highlighting](#)**
# **[Footnotes](#)**
# **[Tables](#)**
# **[Blockquotes](#)**
# **[Inline HTML](#)**
# **[Horizontal Rule](#)**
# **[Line Breaks](#)**
# **[YouTube Videos](#)** 
# Headers
Headers
# H1
## H2
### H3
#### H4
##### H5
###### H6

Alternatively, for H1 and H2, an underline-ish style:

Alt-H1
======

Alt-H2
------
H1
H2
H3
H4
H5
H6
Alternatively, for H1 and H2, an underline-ish style:

Alt-H1
Alt-H2
Emphasis
Emphasis, aka italics, with *asterisks* or _underscores_.

Strong emphasis, aka bold, with **asterisks** or __underscores__.

Combined emphasis with **asterisks and _underscores_**.

Strikethrough uses two tildes. ~~Scratch this.~~
Emphasis, aka italics, with asterisks or underscores.

Strong emphasis, aka bold, with asterisks or underscores.

Combined emphasis with asterisks and underscores.

Strikethrough uses two tildes. Scratch this.

Lists
(In this example, leading and trailing spaces are shown with with dots: ⋅)

1. First ordered list item
2. Another item
⋅⋅* Unordered sub-list. 
1. Actual numbers don't matter, just that it's a number
⋅⋅1. Ordered sub-list
4. And another item.

⋅⋅⋅You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).

⋅⋅⋅To have a line break without a paragraph, you will need to use two trailing spaces.⋅⋅
⋅⋅⋅Note that this line is separate, but within the same paragraph.⋅⋅
⋅⋅⋅(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)

* Unordered list can use asterisks
- Or minuses
+ Or pluses
First ordered list item
Another item
Unordered sub-list.
Actual numbers don't matter, just that it's a number

Ordered sub-list

And another item.

You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).

To have a line break without a paragraph, you will need to use two trailing spaces.
Note that this line is separate, but within the same paragraph.
(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)

Unordered list can use asterisks
Or minuses
Or pluses
Links
There are two ways to create links.

[I'm an inline-style link](https://www.google.com)

[I'm an inline-style link with title](https://www.google.com "Google's Homepage")

[I'm a reference-style link][Arbitrary case-insensitive reference text]

[I'm a relative reference to a repository file](../blob/master/LICENSE)

[You can use numbers for reference-style link definitions][1]

Or leave it empty and use the [link text itself].

URLs and URLs in angle brackets will automatically get turned into links. 
http://www.example.com or <http://www.example.com> and sometimes 
example.com (but not on Github, for example).

Some text to show that the reference links can follow later.

[arbitrary case-insensitive reference text]: https://www.mozilla.org
[1]: http://slashdot.org
[link text itself]: http://www.reddit.com
I'm an inline-style link

I'm an inline-style link with title

I'm a reference-style link

I'm a relative reference to a repository file

You can use numbers for reference-style link definitions

Or leave it empty and use the link text itself.

URLs and URLs in angle brackets will automatically get turned into links. http://www.example.com or http://www.example.com and sometimes example.com (but not on Github, for example).

Some text to show that the reference links can follow later.

Images
Here's our logo (hover to see the title text):

Inline-style: 
![alt text](https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png "Logo Title Text 1")

Reference-style: 
![alt text][logo]

[logo]: https://github.com/adam-p/markdown-here/raw/master/src/common/images/icon48.png "Logo Title Text 2"
Here's our logo (hover to see the title text):

Inline-style: alt text

Reference-style: alt text

Code and Syntax Highlighting
Code blocks are part of the Markdown spec, but syntax highlighting isn't. However, many renderers -- like Github's and Markdown Here -- support syntax highlighting. Which languages are supported and how those language names should be written will vary from renderer to renderer. Markdown Here supports highlighting for dozens of languages (and not-really-languages, like diffs and HTTP headers); to see the complete list, and how to write the language names, see the highlight.js demo page.

Inline `code` has `back-ticks around` it.
Inline code has back-ticks around it.

Blocks of code are either fenced by lines with three back-ticks ```, or are indented with four spaces. I recommend only using the fenced code blocks -- they're easier and only they support syntax highlighting.

```javascript
var s = "JavaScript syntax highlighting";
alert(s);
```
 
```python
s = "Python syntax highlighting"
print s
```
 
```
No language indicated, so no syntax highlighting. 
But let's throw in a <b>tag</b>.
```
var s = "JavaScript syntax highlighting";
alert(s);
s = "Python syntax highlighting"
print s
No language indicated, so no syntax highlighting in Markdown Here (varies on Github). 
But let's throw in a <b>tag</b>.
Footnotes
Footnotes aren't part of the core Markdown spec, but they supported by GFM.

Here is a simple footnote[^1].

A footnote can also have multiple lines[^2].  

You can also use words, to fit your writing style more closely[^note].

[^1]: My reference.
[^2]: Every new line should be prefixed with 2 spaces.  
  This allows you to have a footnote with multiple lines.
[^note]:
    Named footnotes will still render with numbers instead of the text but allow easier identification and linking.  
    This footnote also has been made with a different syntax using 4 spaces for new lines.
Renders to:

rendered footnotes

Tables
Tables aren't part of the core Markdown spec, but they are part of GFM and Markdown Here supports them. They are an easy way of adding tables to your email -- a task that would otherwise require copy-pasting from another application.

Colons can be used to align columns.

| Tables        | Are           | Cool  |
| ------------- |:-------------:| -----:|
| col 3 is      | right-aligned | $1600 |
| col 2 is      | centered      |   $12 |
| zebra stripes | are neat      |    $1 |

There must be at least 3 dashes separating each header cell.
The outer pipes (|) are optional, and you don't need to make the 
raw Markdown line up prettily. You can also use inline Markdown.

Markdown | Less | Pretty
--- | --- | ---
*Still* | `renders` | **nicely**
1 | 2 | 3
Colons can be used to align columns.

Tables	Are	Cool
col 3 is	right-aligned	$1600
col 2 is	centered	$12
zebra stripes	are neat	$1
There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown.

Markdown	Less	Pretty
Still	renders	nicely
1	2	3
Blockquotes
> Blockquotes are very handy in email to emulate reply text.
> This line is part of the same quote.

Quote break.

> This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote. 
Blockquotes are very handy in email to emulate reply text. This line is part of the same quote.

Quote break.

This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can put Markdown into a blockquote.

Inline HTML
You can also use raw HTML in your Markdown, and it'll mostly work pretty well.

<dl>
  <dt>Definition list</dt>
  <dd>Is something people use sometimes.</dd>

  <dt>Markdown in HTML</dt>
  <dd>Does *not* work **very** well. Use HTML <em>tags</em>.</dd>
</dl>
Definition list
Is something people use sometimes.
Markdown in HTML
Does *not* work **very** well. Use HTML tags.
Horizontal Rule
Three or more...

---

Hyphens

***

Asterisks

___

Underscores
Three or more...

Hyphens

Asterisks

Underscores

Line Breaks
My basic recommendation for learning how line breaks work is to experiment and discover -- hit <Enter> once (i.e., insert one newline), then hit it twice (i.e., insert two newlines), see what happens. You'll soon learn to get what you want. "Markdown Toggle" is your friend.

Here are some things to try out:

Here's a line for us to start with.

This line is separated from the one above by two newlines, so it will be a *separate paragraph*.

This line is also a separate paragraph, but...
This line is only separated by a single newline, so it's a separate line in the *same paragraph*.
Here's a line for us to start with.

This line is separated from the one above by two newlines, so it will be a separate paragraph.

This line is also begins a separate paragraph, but...
This line is only separated by a single newline, so it's a separate line in the same paragraph.

(Technical note: Markdown Here uses GFM line breaks, so there's no need to use MD's two-space line breaks.)

YouTube Videos
They can't be added directly but you can add an image with a link to the video like this:

<a href="http://www.youtube.com/watch?feature=player_embedded&v=YOUTUBE_VIDEO_ID_HERE
" target="_blank"><img src="http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg" 
alt="IMAGE ALT TEXT HERE" width="240" height="180" border="10" /></a>
Or, in pure Markdown, but losing the image sizing and border:

[![IMAGE ALT TEXT HERE](http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg)](http://www.youtube.com/watch?v=YOUTUBE_VIDEO_ID_HERE)
Referencing a bug by #bugID in your git commit links it to the slip. For example #1.
</details>


